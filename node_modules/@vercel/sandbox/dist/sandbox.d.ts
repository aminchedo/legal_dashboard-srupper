import type { SandboxMetaData, SandboxRouteData } from "./api-client";
import type { Writable } from "stream";
import { APIClient } from "./api-client";
import { Command, type CommandFinished } from "./command";
import { type Credentials } from "./utils/get-credentials";
/** @inline */
export interface CreateSandboxParams {
    /**
     * The source of the sandbox.
     *
     * Omit this parameter start a sandbox without a source.
     *
     * For git sources:
     * - `depth`: Creates shallow clones with limited commit history (minimum: 1)
     * - `revision`: Clones and checks out a specific commit, branch, or tag
     */
    source?: {
        type: "git";
        url: string;
        depth?: number;
        revision?: string;
    } | {
        type: "git";
        url: string;
        username: string;
        password: string;
        depth?: number;
        revision?: string;
    } | {
        type: "tarball";
        url: string;
    };
    /**
     * Array of port numbers to expose from the sandbox.
     */
    ports?: number[];
    /**
     * Timeout in milliseconds before the sandbox auto-terminates.
     */
    timeout?: number;
    /**
     * Resources to allocate to the sandbox.
     *
     * Your sandbox will get the amount of vCPUs you specify here and
     * 2048 MB of memory per vCPU.
     */
    resources?: {
        vcpus: number;
    };
    /**
     * The runtime of the sandbox, currently only `node22` and `python3.13` are supported.
     * If not specified, the default runtime `node22` will be used.
     */
    runtime?: "node22" | "python3.13" | (string & {});
}
/** @inline */
interface GetSandboxParams {
    /**
     * Unique identifier of the sandbox.
     */
    sandboxId: string;
}
/** @inline */
interface RunCommandParams {
    /**
     * The command to execute
     */
    cmd: string;
    /**
     * Arguments to pass to the command
     */
    args?: string[];
    /**
     * Working directory to execute the command in
     */
    cwd?: string;
    /**
     * Environment variables to set for this command
     */
    env?: Record<string, string>;
    /**
     * If true, execute this command with root privileges. Defaults to false.
     */
    sudo?: boolean;
    /**
     * If true, the command will return without waiting for `exitCode`
     */
    detached?: boolean;
    /**
     * A `Writable` stream where `stdout` from the command will be piped
     */
    stdout?: Writable;
    /**
     * A `Writable` stream where `stderr` from the command will be piped
     */
    stderr?: Writable;
}
/**
 * A Sandbox is an isolated Linux MicroVM to run commands in.
 *
 * Use {@link Sandbox.create} or {@link Sandbox.get} to construct.
 * @hideconstructor
 */
export declare class Sandbox {
    private readonly client;
    /**
     * Routes from ports to subdomains.
    /* @hidden
     */
    readonly routes: SandboxRouteData[];
    /**
     * Unique ID of this sandbox.
     */
    get sandboxId(): string;
    /**
     * The status of the sandbox.
     */
    get status(): SandboxMetaData["status"];
    /**
     * Internal metadata about this sandbox.
     */
    private readonly sandbox;
    /**
     * Create a new sandbox.
     *
     * @param params - Creation parameters and optional credentials.
     * @returns A promise resolving to the created {@link Sandbox}.
     */
    static create(params?: CreateSandboxParams | (CreateSandboxParams & Credentials)): Promise<Sandbox>;
    /**
     * Retrieve an existing sandbox.
     *
     * @param params - Get parameters and optional credentials.
     * @returns A promise resolving to the {@link Sandbox}.
     */
    static get(params: GetSandboxParams | (GetSandboxParams & Credentials)): Promise<Sandbox>;
    /**
     * Create a new Sandbox instance.
     *
     * @param client - API client used to communicate with the backend
     * @param routes - Port-to-subdomain mappings for exposed ports
     * @param sandboxId - Unique identifier for the sandbox
     */
    constructor({ client, routes, sandbox, }: {
        client: APIClient;
        routes: SandboxRouteData[];
        sandbox: SandboxMetaData;
    });
    /**
     * Get a previously run command by its ID.
     *
     * @param cmdId - ID of the command to retrieve
     * @returns A {@link Command} instance representing the command
     */
    getCommand(cmdId: string): Promise<Command>;
    /**
     * Start executing a command in this sandbox.
     *
     * @param command - The command to execute.
     * @param args - Arguments to pass to the command.
     * @returns A {@link CommandFinished} result once execution is done.
     */
    runCommand(command: string, args?: string[]): Promise<CommandFinished>;
    /**
     * Start executing a command in detached mode.
     *
     * @param params - The command parameters.
     * @returns A {@link Command} instance for the running command.
     */
    runCommand(params: RunCommandParams & {
        detached: true;
    }): Promise<Command>;
    /**
     * Start executing a command in this sandbox.
     *
     * @param params - The command parameters.
     * @returns A {@link CommandFinished} result once execution is done.
     */
    runCommand(params: RunCommandParams): Promise<CommandFinished>;
    /**
     * Internal helper to start a command in the sandbox.
     *
     * @param params - Command execution parameters.
     * @returns A {@link Command} or {@link CommandFinished}, depending on `detached`.
     * @internal
     */
    _runCommand(params: RunCommandParams): Promise<CommandFinished | Command>;
    /**
     * Create a directory in the filesystem of this sandbox.
     *
     * @param path - Path of the directory to create
     */
    mkDir(path: string): Promise<void>;
    /**
     * Read a file from the filesystem of this sandbox.
     *
     * @param file - File to read, with path and optional cwd
     * @returns A promise that resolves to a ReadableStream containing the file contents
     */
    readFile(file: {
        path: string;
        cwd?: string;
    }): Promise<NodeJS.ReadableStream | null>;
    /**
     * Write files to the filesystem of this sandbox.
     *
     * @param files - Array of files with path and stream/buffer contents
     * @returns A promise that resolves when the files are written
     */
    writeFiles(files: {
        path: string;
        content: Buffer;
    }[]): Promise<void>;
    /**
     * Get the public domain of a port of this sandbox.
     *
     * @param p - Port number to resolve
     * @returns A full domain (e.g. `https://subdomain.vercel.run`)
     * @throws If the port has no associated route
     */
    domain(p: number): string;
    /**
     * Stop the sandbox.
     *
     * @returns A promise that resolves when the sandbox is stopped
     */
    stop(): Promise<void>;
}
export {};
