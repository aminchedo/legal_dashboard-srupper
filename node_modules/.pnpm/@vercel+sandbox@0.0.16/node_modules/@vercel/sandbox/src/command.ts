import { APIClient, type CommandData } from "./api-client";
import { Signal, resolveSignal } from "./utils/resolveSignal";

/**
 * A command executed in a Sandbox.
 *
 * You can {@link wait} on commands to access their {@link CommandFinished.exitCode}, and
 * iterate over their output with {@link logs}.
 *
 * @see {@link Sandbox.runCommand} to start a command.
 *
 * @hideconstructor
 */
export class Command {
  /**
   * @internal
   * @private
   */
  protected client: APIClient;

  /**
   * ID of the sandbox this command is running in.
   */
  private sandboxId: string;

  /**
   * Data for the command execution.
   */
  private cmd: CommandData;

  public exitCode: number | null;

  /**
   * ID of the command execution.
   */
  get cmdId() {
    return this.cmd.id;
  }

  get cwd() {
    return this.cmd.cwd;
  }

  get startedAt() {
    return this.cmd.startedAt;
  }

  /**
   * @param params - Object containing the client, sandbox ID, and command ID.
   * @param params.client - API client used to interact with the backend.
   * @param params.sandboxId - The ID of the sandbox where the command is running.
   * @param params.cmdId - The ID of the command execution.
   */
  constructor({
    client,
    sandboxId,
    cmd,
  }: {
    client: APIClient;
    sandboxId: string;
    cmd: CommandData;
  }) {
    this.client = client;
    this.sandboxId = sandboxId;
    this.cmd = cmd;
    this.exitCode = cmd.exitCode ?? null;
  }

  /**
   * Iterate over the output of this command.
   *
   * ```
   * for await (const log of cmd.logs()) {
   *   if (log.stream === "stdout") {
   *     process.stdout.write(log.data);
   *   } else {
   *     process.stderr.write(log.data);
   *   }
   * }
   * ```
   *
   * @returns An async iterable of log entries from the command output.
   *
   * @see {@link Command.stdout}, {@link Command.stderr}, and {@link Command.output}
   * to access output as a string.
   */
  logs() {
    return this.client.getLogs({
      sandboxId: this.sandboxId,
      cmdId: this.cmd.id,
    });
  }

  /**
   * Wait for a command to exit and populate its exit code.
   *
   * ```
   * await cmd.wait()
   * if (cmd.exitCode != 0) {
   *   console.error("Something went wrong...")
   * }
   * ```
   *
   * @returns A {@link CommandFinished} instance with populated exit code.
   */
  async wait() {
    const command = await this.client.getCommand({
      sandboxId: this.sandboxId,
      cmdId: this.cmd.id,
      wait: true,
    });

    return new CommandFinished({
      client: this.client,
      sandboxId: this.sandboxId,
      cmd: command.json.command,
      exitCode: command.json.command.exitCode,
    });
  }

  /**
   * Get the output of `stdout`, `stderr`, or both as a string.
   *
   * NOTE: This may throw string conversion errors if the command does
   * not output valid Unicode.
   *
   * @param stream - The output stream to read: "stdout", "stderr", or "both".
   * @returns The output of the specified stream(s) as a string.
   */
  async output(stream: "stdout" | "stderr" | "both" = "both") {
    let data = "";
    for await (const log of this.logs()) {
      if (stream === "both" || log.stream === stream) {
        data += log.data;
      }
    }
    return data;
  }

  /**
   * Get the output of `stdout` as a string.
   *
   * NOTE: This may throw string conversion errors if the command does
   * not output valid Unicode.
   *
   * @returns The standard output of the command.
   */
  async stdout() {
    return this.output("stdout");
  }

  /**
   * Get the output of `stderr` as a string.
   *
   * NOTE: This may throw string conversion errors if the command does
   * not output valid Unicode.
   *
   * @returns The standard error output of the command.
   */
  async stderr() {
    return this.output("stderr");
  }

  /**
   * Kill a running command in a sandbox.
   *
   * @param params - commandId and the signal to send the running process.
   * Defaults to SIGTERM.
   * @returns Promise<void>.
   */
  async kill(signal?: Signal) {
    await this.client.killCommand({
      sandboxId: this.sandboxId,
      commandId: this.cmd.id,
      signal: resolveSignal(signal ?? "SIGTERM"),
    });
  }
}

/**
 * A command that has finished executing.
 *
 * Contains the exit code of the command.
 *
 * @hideconstructor
 */
export class CommandFinished extends Command {
  /**
   * The exit code of the command, if available. This is set after
   * {@link wait} has returned.
   */
  public exitCode: number;

  /**
   * @param params - Object containing client, sandbox ID, command ID, and exit code.
   * @param params.client - API client used to interact with the backend.
   * @param params.sandboxId - The ID of the sandbox where the command ran.
   * @param params.cmdId - The ID of the command execution.
   * @param params.exitCode - The exit code of the completed command.
   */
  constructor(params: {
    client: APIClient;
    sandboxId: string;
    cmd: CommandData;
    exitCode: number;
  }) {
    super({ ...params });
    this.exitCode = params.exitCode;
  }
}
