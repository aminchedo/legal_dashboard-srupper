import {
  BaseClient,
  parseOrThrow,
  type Parsed,
  type RequestParams,
} from "./base-client";
import {
  SandboxAndRoutesResponse,
  SandboxResponse,
  CommandResponse,
  CommandFinishedResponse,
  EmptyResponse,
  LogLine,
} from "./validators";
import { APIError } from "./api-error";
import { FileWriter } from "./file-writer";
import { VERSION } from "../version";
import { consumeReadable } from "../utils/consume-readable";
import { z } from "zod";
import jsonlines from "jsonlines";
import os from "os";
import { Readable } from "stream";

export class APIClient extends BaseClient {
  private teamId: string;

  constructor(params: { host?: string; teamId: string; token: string }) {
    super({
      host: params.host ?? "https://api.vercel.com",
      token: params.token,
      debug: false,
    });

    this.teamId = params.teamId;
  }

  protected async request(path: string, params?: RequestParams) {
    return super.request(path, {
      ...params,
      query: { teamId: this.teamId, ...params?.query },
      headers: {
        "content-type": "application/json",
        "user-agent": `vercel/sandbox/${VERSION} (Node.js/${process.version}; ${os.platform()}/${os.arch()})`,
        ...params?.headers,
      },
    });
  }

  async getSandbox(params: { sandboxId: string }) {
    return parseOrThrow(
      SandboxAndRoutesResponse,
      await this.request(`/v1/sandboxes/${params.sandboxId}`),
    );
  }

  async createSandbox(params: {
    ports?: number[];
    projectId: string;
    source?:
      | {
          type: "git";
          url: string;
          depth?: number;
          revision?: string;
          username?: string;
          password?: string;
        }
      | { type: "tarball"; url: string };
    timeout?: number;
    resources?: { vcpus: number };
    runtime?: "node22" | "python3.13" | (string & {});
  }) {
    return parseOrThrow(
      SandboxAndRoutesResponse,
      await this.request("/v1/sandboxes", {
        method: "POST",
        body: JSON.stringify({
          projectId: params.projectId,
          ports: params.ports,
          source: params.source,
          timeout: params.timeout,
          resources: params.resources,
          runtime: params.runtime,
        }),
      }),
    );
  }

  async runCommand(params: {
    sandboxId: string;
    cwd?: string;
    command: string;
    args: string[];
    env: Record<string, string>;
    sudo: boolean;
  }) {
    return parseOrThrow(
      CommandResponse,
      await this.request(`/v1/sandboxes/${params.sandboxId}/cmd`, {
        method: "POST",
        body: JSON.stringify({
          command: params.command,
          args: params.args,
          cwd: params.cwd,
          env: params.env,
          sudo: params.sudo,
        }),
      }),
    );
  }

  async getCommand(params: {
    sandboxId: string;
    cmdId: string;
    wait: true;
  }): Promise<Parsed<z.infer<typeof CommandFinishedResponse>>>;
  async getCommand(params: {
    sandboxId: string;
    cmdId: string;
    wait?: boolean;
  }): Promise<Parsed<z.infer<typeof CommandResponse>>>;
  async getCommand(params: {
    sandboxId: string;
    cmdId: string;
    wait?: boolean;
  }) {
    return params.wait
      ? parseOrThrow(
          CommandFinishedResponse,
          await this.request(
            `/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}`,
            { query: { wait: "true" } },
          ),
        )
      : parseOrThrow(
          CommandResponse,
          await this.request(
            `/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}`,
          ),
        );
  }

  async mkDir(params: { sandboxId: string; path: string; cwd?: string }) {
    return parseOrThrow(
      EmptyResponse,
      await this.request(`/v1/sandboxes/${params.sandboxId}/fs/mkdir`, {
        method: "POST",
        body: JSON.stringify({ path: params.path, cwd: params.cwd }),
      }),
    );
  }

  getFileWriter(params: { sandboxId: string }) {
    const writer = new FileWriter();
    return {
      response: (async () => {
        return this.request(`/v1/sandboxes/${params.sandboxId}/fs/write`, {
          method: "POST",
          headers: { "content-type": "application/gzip" },
          body: await consumeReadable(writer.readable),
        });
      })(),
      writer,
    };
  }

  async writeFiles(params: {
    sandboxId: string;
    files: { path: string; content: Buffer }[];
  }) {
    const { writer, response } = this.getFileWriter({
      sandboxId: params.sandboxId,
    });

    for (const file of params.files) {
      await writer.addFile({ name: file.path, content: file.content });
    }

    writer.end();
    await parseOrThrow(EmptyResponse, await response);
  }

  async readFile(params: {
    sandboxId: string;
    path: string;
    cwd?: string;
  }): Promise<NodeJS.ReadableStream | null> {
    const response = await this.request(
      `/v1/sandboxes/${params.sandboxId}/fs/read`,
      {
        method: "POST",
        body: JSON.stringify({ path: params.path, cwd: params.cwd }),
      },
    );

    if (response.status === 404) {
      return null;
    }

    if (response.body === null) {
      return null;
    }

    return Readable.fromWeb(response.body);
  }

  async killCommand(params: {
    sandboxId: string;
    commandId: string;
    signal: number;
  }) {
    return parseOrThrow(
      CommandResponse,
      await this.request(
        `/v1/sandboxes/${params.sandboxId}/${params.commandId}/kill`,
        {
          method: "POST",
          body: JSON.stringify({ signal: params.signal }),
        },
      ),
    );
  }

  async *getLogs(params: {
    sandboxId: string;
    cmdId: string;
  }): AsyncIterable<z.infer<typeof LogLine>> {
    const url = `/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}/logs`;
    const response = await this.request(url, { method: "GET" });
    if (response.headers.get("content-type") !== "application/x-ndjson") {
      throw new APIError(response, {
        message: "Expected a stream of logs",
      });
    }

    if (response.body === null) {
      throw new APIError(response, {
        message: "No response body",
      });
    }

    for await (const chunk of Readable.fromWeb(response.body).pipe(
      jsonlines.parse(),
    )) {
      yield LogLine.parse(chunk);
    }
  }

  async stopSandbox(params: {
    sandboxId: string;
  }): Promise<Parsed<z.infer<typeof SandboxResponse>>> {
    const url = `/v1/sandboxes/${params.sandboxId}/stop`;
    return parseOrThrow(
      SandboxResponse,
      await this.request(url, { method: "POST" }),
    );
  }
}
