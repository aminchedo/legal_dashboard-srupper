"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.APIClient = void 0;
const base_client_1 = require("./base-client");
const validators_1 = require("./validators");
const api_error_1 = require("./api-error");
const file_writer_1 = require("./file-writer");
const version_1 = require("../version");
const consume_readable_1 = require("../utils/consume-readable");
const jsonlines_1 = __importDefault(require("jsonlines"));
const os_1 = __importDefault(require("os"));
const stream_1 = require("stream");
class APIClient extends base_client_1.BaseClient {
    constructor(params) {
        super({
            host: params.host ?? "https://api.vercel.com",
            token: params.token,
            debug: false,
        });
        this.teamId = params.teamId;
    }
    async request(path, params) {
        return super.request(path, {
            ...params,
            query: { teamId: this.teamId, ...params?.query },
            headers: {
                "content-type": "application/json",
                "user-agent": `vercel/sandbox/${version_1.VERSION} (Node.js/${process.version}; ${os_1.default.platform()}/${os_1.default.arch()})`,
                ...params?.headers,
            },
        });
    }
    async getSandbox(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.SandboxAndRoutesResponse, await this.request(`/v1/sandboxes/${params.sandboxId}`));
    }
    async createSandbox(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.SandboxAndRoutesResponse, await this.request("/v1/sandboxes", {
            method: "POST",
            body: JSON.stringify({
                projectId: params.projectId,
                ports: params.ports,
                source: params.source,
                timeout: params.timeout,
                resources: params.resources,
                runtime: params.runtime,
            }),
        }));
    }
    async runCommand(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.CommandResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/cmd`, {
            method: "POST",
            body: JSON.stringify({
                command: params.command,
                args: params.args,
                cwd: params.cwd,
                env: params.env,
                sudo: params.sudo,
            }),
        }));
    }
    async getCommand(params) {
        return params.wait
            ? (0, base_client_1.parseOrThrow)(validators_1.CommandFinishedResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}`, { query: { wait: "true" } }))
            : (0, base_client_1.parseOrThrow)(validators_1.CommandResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}`));
    }
    async mkDir(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.EmptyResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/fs/mkdir`, {
            method: "POST",
            body: JSON.stringify({ path: params.path, cwd: params.cwd }),
        }));
    }
    getFileWriter(params) {
        const writer = new file_writer_1.FileWriter();
        return {
            response: (async () => {
                return this.request(`/v1/sandboxes/${params.sandboxId}/fs/write`, {
                    method: "POST",
                    headers: { "content-type": "application/gzip" },
                    body: await (0, consume_readable_1.consumeReadable)(writer.readable),
                });
            })(),
            writer,
        };
    }
    async writeFiles(params) {
        const { writer, response } = this.getFileWriter({
            sandboxId: params.sandboxId,
        });
        for (const file of params.files) {
            await writer.addFile({ name: file.path, content: file.content });
        }
        writer.end();
        await (0, base_client_1.parseOrThrow)(validators_1.EmptyResponse, await response);
    }
    async readFile(params) {
        const response = await this.request(`/v1/sandboxes/${params.sandboxId}/fs/read`, {
            method: "POST",
            body: JSON.stringify({ path: params.path, cwd: params.cwd }),
        });
        if (response.status === 404) {
            return null;
        }
        if (response.body === null) {
            return null;
        }
        return stream_1.Readable.fromWeb(response.body);
    }
    async killCommand(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.CommandResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/${params.commandId}/kill`, {
            method: "POST",
            body: JSON.stringify({ signal: params.signal }),
        }));
    }
    async *getLogs(params) {
        const url = `/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}/logs`;
        const response = await this.request(url, { method: "GET" });
        if (response.headers.get("content-type") !== "application/x-ndjson") {
            throw new api_error_1.APIError(response, {
                message: "Expected a stream of logs",
            });
        }
        if (response.body === null) {
            throw new api_error_1.APIError(response, {
                message: "No response body",
            });
        }
        for await (const chunk of stream_1.Readable.fromWeb(response.body).pipe(jsonlines_1.default.parse())) {
            yield validators_1.LogLine.parse(chunk);
        }
    }
    async stopSandbox(params) {
        const url = `/v1/sandboxes/${params.sandboxId}/stop`;
        return (0, base_client_1.parseOrThrow)(validators_1.SandboxResponse, await this.request(url, { method: "POST" }));
    }
}
exports.APIClient = APIClient;
