"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandFinished = exports.Command = void 0;
const resolveSignal_1 = require("./utils/resolveSignal");
/**
 * A command executed in a Sandbox.
 *
 * You can {@link wait} on commands to access their {@link CommandFinished.exitCode}, and
 * iterate over their output with {@link logs}.
 *
 * @see {@link Sandbox.runCommand} to start a command.
 *
 * @hideconstructor
 */
class Command {
    /**
     * ID of the command execution.
     */
    get cmdId() {
        return this.cmd.id;
    }
    get cwd() {
        return this.cmd.cwd;
    }
    get startedAt() {
        return this.cmd.startedAt;
    }
    /**
     * @param params - Object containing the client, sandbox ID, and command ID.
     * @param params.client - API client used to interact with the backend.
     * @param params.sandboxId - The ID of the sandbox where the command is running.
     * @param params.cmdId - The ID of the command execution.
     */
    constructor({ client, sandboxId, cmd, }) {
        this.client = client;
        this.sandboxId = sandboxId;
        this.cmd = cmd;
        this.exitCode = cmd.exitCode ?? null;
    }
    /**
     * Iterate over the output of this command.
     *
     * ```
     * for await (const log of cmd.logs()) {
     *   if (log.stream === "stdout") {
     *     process.stdout.write(log.data);
     *   } else {
     *     process.stderr.write(log.data);
     *   }
     * }
     * ```
     *
     * @returns An async iterable of log entries from the command output.
     *
     * @see {@link Command.stdout}, {@link Command.stderr}, and {@link Command.output}
     * to access output as a string.
     */
    logs() {
        return this.client.getLogs({
            sandboxId: this.sandboxId,
            cmdId: this.cmd.id,
        });
    }
    /**
     * Wait for a command to exit and populate its exit code.
     *
     * ```
     * await cmd.wait()
     * if (cmd.exitCode != 0) {
     *   console.error("Something went wrong...")
     * }
     * ```
     *
     * @returns A {@link CommandFinished} instance with populated exit code.
     */
    async wait() {
        const command = await this.client.getCommand({
            sandboxId: this.sandboxId,
            cmdId: this.cmd.id,
            wait: true,
        });
        return new CommandFinished({
            client: this.client,
            sandboxId: this.sandboxId,
            cmd: command.json.command,
            exitCode: command.json.command.exitCode,
        });
    }
    /**
     * Get the output of `stdout`, `stderr`, or both as a string.
     *
     * NOTE: This may throw string conversion errors if the command does
     * not output valid Unicode.
     *
     * @param stream - The output stream to read: "stdout", "stderr", or "both".
     * @returns The output of the specified stream(s) as a string.
     */
    async output(stream = "both") {
        let data = "";
        for await (const log of this.logs()) {
            if (stream === "both" || log.stream === stream) {
                data += log.data;
            }
        }
        return data;
    }
    /**
     * Get the output of `stdout` as a string.
     *
     * NOTE: This may throw string conversion errors if the command does
     * not output valid Unicode.
     *
     * @returns The standard output of the command.
     */
    async stdout() {
        return this.output("stdout");
    }
    /**
     * Get the output of `stderr` as a string.
     *
     * NOTE: This may throw string conversion errors if the command does
     * not output valid Unicode.
     *
     * @returns The standard error output of the command.
     */
    async stderr() {
        return this.output("stderr");
    }
    /**
     * Kill a running command in a sandbox.
     *
     * @param params - commandId and the signal to send the running process.
     * Defaults to SIGTERM.
     * @returns Promise<void>.
     */
    async kill(signal) {
        await this.client.killCommand({
            sandboxId: this.sandboxId,
            commandId: this.cmd.id,
            signal: (0, resolveSignal_1.resolveSignal)(signal ?? "SIGTERM"),
        });
    }
}
exports.Command = Command;
/**
 * A command that has finished executing.
 *
 * Contains the exit code of the command.
 *
 * @hideconstructor
 */
class CommandFinished extends Command {
    /**
     * @param params - Object containing client, sandbox ID, command ID, and exit code.
     * @param params.client - API client used to interact with the backend.
     * @param params.sandboxId - The ID of the sandbox where the command ran.
     * @param params.cmdId - The ID of the command execution.
     * @param params.exitCode - The exit code of the completed command.
     */
    constructor(params) {
        super({ ...params });
        this.exitCode = params.exitCode;
    }
}
exports.CommandFinished = CommandFinished;
